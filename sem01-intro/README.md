

# Инструментарий разработчика
Введем для начала пару ключевых понятий
 
 **Ядро ОС** — это центральная часть операционной системы, которая управляет ресурсами компьютера (процессором, памятью, устройствами ввода/вывода) и обеспечивает работу всех программ.

Можно представить его как «дирижёра» оркестра: оно не играет само, но управляет всеми инструментами (процессами), чтобы они работали согласованно.

Основные функции ядра:

* Управление процессами — запуск, планирование, переключение между ними.

* Управление памятью — выделение и защита памяти для разных программ.

* Управление устройствами — драйверы, работа с диском, сетью, клавиатурой, экраном и т.д.

* Системные вызовы — интерфейс между программами и железом (например, read, write, fork, exec).

**Процесс** — это экземпляр выполняющейся программы вместе со всеми её ресурсами (память, открытые файлы, контекст процессора).
```
+------------------+
|   Исходный код   |   (C, C++)
+------------------+
          |
          v
   [ GCC (этапы) ]
   ┌─────────────┬─────────────┬─────────────┬─────────────┐
   | Препроцесс  | Компиляция  | Ассемблер   | Линковка    |
   | (macros,    | (C → ASM)   | (ASM → obj) | (obj+libs → |
   | includes)   |             |             | бинарь)     |
   └─────────────┴─────────────┴─────────────┴─────────────┘
          |
          v
+------------------+
|  Исполняемый код |
+------------------+
          |
          v
+------------------+
|   Отладка (GDB)  |
|   Анализ (ASan,  |
|   Valgrind,      |
|   Strace)        |
+------------------+
```

## GCC

> Вопросы на повторение:
>
> * Что такое компилятор?
> * Зачем писать новые компиляторы?
> * Можно ли будет любую программу этого курса скомпилировать на Apple M1, например?
> * Какие есть этапы компиляции?

В это курсе мы будем использовать компилятор `gcc`. В простейшем случае, чтобы скомпилировать программу из одного файла, можно просто написать:

```bash
gcc file.c
```

Называться по-умолчанию выходной бинарный файл будет `a.out`. Переопределить это имя можно с помощью опции `-o`.

---

### Макросы

1. **Макрос-константа** (замена на значение):

```c
#define PI 3.14159

int main() {
    double r = 2.0;
    double len = 2 * PI * r;  // вместо PI подставится 3.14159
}
```

2. **Макрос-функция** (подстановка с аргументами):

```c
#define SQR(x) ((x) * (x))

int a = SQR(5);    // → ((5) * (5))
int b = SQR(1+2);  // → ((1+2) * (1+2))
```

3. **Условные макросы**:

```c
#ifdef DEBUG
    printf("Debug info\n");
#endif
```

---

**Макрос — это правило для препроцессора, которое говорит: «замени все вхождения этого слова на указанный текст перед тем, как начнётся компиляция».**

---

⚡ Важно: макросы — не то же самое, что `const` или `inline` функции.

* `#define` работает до компиляции (текст подставляется вслепую).
* `const` и `inline` учитывают типы и проверяются компилятором.

---




## Этапы компиляции

Давайте рассмотрим этапы компиляции на примере простой программы ``aplusb.c``.

### 1. Препроцессинг: 
разворачиваются `include` и `define`, удаляем комментарии. Выполним только эту стадию: ``gcc -E aplusb.c -o aplusb_preprocessed.c``
> Что за комментарии препроцессор оставляет в начале? 

#### Line markers (служебные директивы `# …` в начале препроцессированного файла)

Если скомпилировать программу только с препроцессингом:

```bash
gcc -E aplusb.c -o aplusb_pre.c
```

в начале файла вы увидите строки вида:

```
# 1 "aplusb.c"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 418 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "aplusb.c" 2
```

Это не ваши макросы, а **line markers**. Они нужны компилятору, чтобы не потерять связь между строками оригинального файла и развернутым кодом.

Формат строки:

```
# <номер строки> "<имя файла>" <флаги>
```

Флаги:

* `1` — начало нового файла (`#include`, `<built-in>` и т.п.)
* `2` — возврат в предыдущий файл
* `3` — системный заголовок (предупреждения в нём подавляются)
* `4` — для C++: следующий код считается `extern "C"`

`<built-in>` — это блок встроенных определений компилятора (`__GNUC__`, `__STDC__`, `__x86_64__` и т.д.).
`<command line>` — макросы, переданные через опции `-D` при запуске gcc.

Если хотите увидеть **все встроенные макросы**, используйте:

```bash
echo | gcc -E -dM -
```

Если хотите скрыть line markers и получить «чистый» код:

```bash
gcc -E -P aplusb.c -o aplusb_pre.c
```
Хорошо написано про это еще здесь: https://stackoverflow.com/questions/49109904/how-to-interpret-prefixed-lines-in-c-preprocessor-output

### 2. Компиляция: код на C превращается в ASM
> На самом деле ASM не обозначает какой-то один язык. Это семейство низкоуровневых платформоспецифичных языков. На курсе мы с вами будем разбирать ARM и x86 диалекты, но есть и множество других для менее известных архитектур(AVR - Arduino, PIC - для бытовой техники, MIPS - Playstation 2 и т.д.). 

``gcc -S aplusb_preprocessed.c -o aplusb_asm.S``

### 3. Ассемблирование: код на ассемблере преобразуется в машинный код.

``gcc -c aplusb_asm.S -o aplusb_object.o``

В целом, ассемблер и так сильно к нему приближен. С помощью утилиты ``objdump`` можно удобно рассматривать объектные файлы. В частности, флаг ``-d`` позволяет посмотреть на ассемблерный код.

### 4. Компоновка/Линковка: объектные файлы собираются в один бинарный (на этом этапе разрешаются зависимости, например ``glibc``)
> glibc (GNU C Library) — это реализация стандартной библиотеки языка C для Linux и Unix-подобных систем. Это именно та библиотека, где лежат все привычные функции из <stdio.h>, <stdlib.h>, <string.h> и других заголовков
``gcc aplusb_object.o -o aplusb_executable.out``


# Виды линковки
## По моменту выполнения

В системном программировании под линковкой понимают процесс связывания объектных файлов и библиотек в готовый исполняемый файл. Здесь различают два основных подхода:

### Статическая линковка (static linking)

* Код необходимых библиотек **встраивается** в исполняемый файл на этапе сборки.
* В итоге программа не зависит от внешних `.so`/`.dll` файлов.
* Используется ключ `-static`:

  ```bash
  gcc main.c -o app_static -static
  ```
* **Плюсы**: автономность, можно запускать без дополнительных библиотек.
* **Минусы**: большой размер бинарника, обновление библиотек требует пересборки.

### Динамическая линковка (dynamic linking)

* В исполняемом файле остаются **ссылки** на функции библиотек.
* Код библиотек не вшивается в бинарь, а подгружается ОС при запуске.
* Пример (по умолчанию):

  ```bash
  gcc main.c -o app
  ldd app    # показывает зависимости
  ```
* **Плюсы**: экономия памяти и диска, обновления библиотек автоматически влияют на программы.
* **Минусы**: требуется наличие правильных версий библиотек в системе.

---

## По видимости символов (linkage в смысле C/C++)

Стандарт C/C++ использует слово *linkage* в другом смысле — для обозначения того, как имена функций и переменных видимы между единицами трансляции.

### Внешняя линковка (external linkage)

* Символ доступен из других файлов.
* По умолчанию у глобальных функций и переменных.

```c
int global = 42;   // external linkage
```

```c
extern int global; // обращение к переменной из другого файла
```

### Внутренняя линковка (internal linkage)

* Символ виден только внутри текущего файла.
* Объявляется с `static` на глобальном уровне.

```c
static int counter = 0;   // internal linkage
static void helper() {}   // доступна только в этом .c файле
```

### Без линковки (no linkage)

* Имя существует только в своей области (например, локальные переменные функции).

```c
void foo() {
    int x = 10;   // no linkage
}
```

## Makefile

Удобно выполнять сборку одно командой ``gcc`` в случае, если надо собрать проекты из пары файлов. Для больших проектов нужен некий инструмент автоматизации, системы сборки. Одна из простейших из них -- `make`. `Makefile` состоит из целей, которые берут некоторые зависимости и применяют к ним команды сборки. 

Основной формат (в качетсве отступа используется именно табуляция)
```
target: prerequisite1 ... prerequisite_n
    command_1
    ...
    command_n
```
* target — цель: файл, который хотим получить (например, program, main.o, all).

* prerequisites — список файлов или целей, от которых зависит target.

* command — что надо сделать, чтобы получить target.

В качестве примера можно посмотреть на ``Makefile`` в этой папке.

Make не хранит своё состояние. Поэтому пересборка цели не выполняется лишь в одном случае: имя цели является файлом, и время его модификации больше времени модификации всех зависимостей цели.

> Мы обсудили простейший сценарий. На самом деле, Make поддерживает циклы, функции и так далее. Подробнее про это можно почитать на https://makefiletutorial.com/. Ещё подробнее в официальной документации: https://www.gnu.org/software/make/manual/make.html

## GDB

GDB (GNU Debugger) — это отладчик для программ на C, C++.

Возможно, вы уже дебажили с помощью логирования. Но иногда удобнее воспользоваться отладчиком. Опция ``-g`` позволяет снабдить файл дополнительной информацией для отладки.

``gcc -g aplusb.c -o aplusb_debug.out``

Запустим бинарный файл под отладчиком ``gdb``

``gdb ./aplusb_debug.out``

Поставим точку останова: ``b 7``

Запустим исполнение: ``run``.

С помощью ``layout src`` можно посмотреть на исходный код.

Дальше с помощью ``ni`` можно переключаться на следующую инструкцию (если нужно зайти в функции, используем ``si``).

С помощью ``print`` можно вывести значения переменной.

Чтобы выйти из отладки, можно использовать команду ``q``.

> Шпаргалка по GDB https://darkdust.net/files/GDB%20Cheat%20Sheet.pdf

Попробуем под ``gdb`` запустить падающую программу.

``gcc -g bad.c -o bad.out``

Чтобы сразу выполнить программу, можно передать команды ``gdb`` в аргумент ``ex``.

``gdb -ex=r ./bad.out``

Видим строчку, в которой произошёл Segfault. 

С помощью команды ``bt`` можно вывести stacktrace. 

> Кадр стека (stack frame) — это участок памяти в стеке, который выделяется на время одного вызова функции. В нём хранится всё, что нужно(локальные переменные, адрес возврата, сохраненные регистры и т.д.), чтобы выполнить функцию и корректно вернуться к месту вызова.

Дальшё с помощью ``frame 0`` можно переключиться на верхний фрейм.

``info args`` покажет аргументы, с которыми была вызвана функция.

``info locals`` выведет локальные переменные.

> В прошлых двух мы тоже вышли за границы массива, но почему-то не упали. Узнаете, почему, когда сходите на лекцию про виртуальную память процесса.

В жизни часто возникает необходимость проанализировать на падение программы, в которой были отладочные символы, но запущена она была не под дебаггером. Для этого используются специальные ``coredump`` файлы, которые сохраняют состояние процесса на момент падения.

Попросим складывать файлы в текущую папку:

``sudo sysctl kernel.core_pattern="./coredump"``

Разрешим создавать ``coredump`` файлы большого размера и выполним программу.

``ulimit -c unlimited; ./bad.out``

Теперь можно проанализировать ``coredump``. 

``gdb ./bad.out ./coredump``

Ну а дальше можно повторить все манипуляции, которые мы делали ранее.

## Sanitizers

Обычно проблемы целесообразно ловить на как можно более ранних этапах. В прошлом пункте мы разобрались, как можно проанализировать упавшую программу, в этом разбёремся, как частично отлавливать их на этапе компиляции. Adress Sanitizer позволяет отлавливать выход за границы массива, утечки памяти и некоторые другие ошибки. Подробнее можно почитать по [ссылке](https://github.com/google/sanitizers/wiki/AddressSanitizer).

``gcc -fsanitize=address bad.c -o bad.out``

Можно заметить, что размер бинарного файла увеличился, потому что сгенерировались некоторые дополнительные проверки. Исполнение из-за них также замедлится примерно в 2 раза, но это допустимо для отладочной сборки Зато теперь, если мы запустим программу, при падении увидим сильно более понятное сообщение об ошибке. 

## Valgrind

**Valgrind** — это инструмент для динамического анализа программ.
Он запускает твой бинарь в «виртуальной машине» (эмуляторе CPU), перехватывает все обращения к памяти и системные вызовы.

Основное назначение: поиск ошибок работы с памятью и утечек.

* **Memcheck** (самый популярный режим):

  * выявляет утечки памяти,
  * использование освобождённой памяти (*use-after-free*),
  * чтение/запись за границами массива,
  * чтение неинициализированной памяти.

* **Callgrind** — профилирование (показывает, какие функции «съели» больше всего процессорного времени).

* **Cachegrind** — анализ использования кэша CPU.

* **Helgrind / DRD** — поиск ошибок многопоточности (data race, неправильные блокировки).

* **Massif** — измерение использования памяти (heap profiler).

---

## Как использовать

Компиляция с отладочной информацией:

```bash
gcc -g main.c -o main
```

Запуск под Valgrind:

```bash
valgrind ./main
```

Проверка утечек памяти:

```bash
valgrind --leak-check=full ./main
```

## Отличие от Sanitizers

* **Valgrind**: не требует пересборки, работает даже с чужими бинарями, медленный.
* **AddressSanitizer**: требует пересборки, работает быстро, но не всегда ловит неинициализированную память.



## Strace

На лекции рассказали про то, что ядро предоставляет некоторый API системных вызовов. Они используются, например, для взаимодействия с железом, создания процессов и межпроцессорной коммуникации. С помощью утилиты ``strace`` можно посмотреть список системных вызовов, которые вызывает ваша программа.

``strace ./bad.out``

В начале мы выделяем память, потом загружаем в неё динамические библиотеки, после этого и записываем данные с помощью системных вызова ``write``, и, наконец, завершаем программу с помощью системного вызова ``exit_group``.
