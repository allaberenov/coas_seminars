# Многопоточная синхронизация

Операции чтения и записи с традиционными типами не являются атомарными. То есть тот же инкремент с точки зрения ассемблера выглядит как-то так.

```
ldr rax, rsp
inc rax
mov rsp, rax
```

А что если мы делаем инкремент из двух потоков? Мы можем в обоих потоках сначала прочитать значение, а потом записать. Тогда мы увеличим значение только на 1, а не на 2, как должны были. Состояние, когда два потока обращаются одновремененно к ячейке памяти, и хотя бы одна из них пищущая, называется гонкой (data race). Позапускав `no_sync.c`, можно увидеть, что сумма получается разной, то есть поведение не определено. Хочется такого избежать. Для этого нужно синхронизировать (упорядочить) обращения к памяти.


## Обзор примитивов синхронизации
Примитивы синхронизации — это механизмы, которые позволяют управлять порядком выполнения потоков и их доступом к разделяемым ресурсам. Они нужны, чтобы предотвращать состояния гонки, координировать потоки и упорядочивать операции памяти.
Основные типы примитивов синхронизации можно разделить по назначению.

Виды синхронизации.

* Мьютекс
* Condvar (условная переменная)
* Семафор
* Спинлок
* Барьер
* Reader-Writer Lock
* Атомарные операции

## Mutex
Критической секцией будем называть участок кода, в котором одновременно может выполняться не более одного потока.
Один из способов обеспечить это — использовать мьютекс (mutual exclusion lock).
Мьютекс — это объект синхронизации, который позволяет только одному потоку захватить его и войти в критическую секцию.
Если другой поток попытается сделать то же самое, пока мьютекс занят, он будет заблокирован до тех пор, пока первый поток не освободит мьютекс.

#### Как можно реализовать мьютекс?
> См. `try_mutext1.с`  и `try_mutex2.c`. Почему первый вариант плох?

Мы с вами написали spinlock! Ну почти, разве что spinclock использует атомарные инструкции о которых речь пойдет ниже.

Мьютекс реализован по такой же схеме, кроме того, что поток не висит в случае блокировки мьютекса в состоянии `busy wait`, а засыпает. Сделано это для оптимизации. На самом же деле реальная реализация `mutex` использует атомарные инструкции процесса `xch`, `cpxch`, `test_and_set`, а также системный механизм `futex`.   

Mutex объявлен в `pthread` и предоставляет следующий интерфейс:


 * `pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr)` - инициализация мьютекса для его последующего использования.
 * `pthread_mutex_destroy(pthread_mutex_t *mutex)` - уничтожить ранее созданный мьютекс.
 * `pthread_mutex_lock(pthread_mutex_t *mutex)` - захватить мьютекс. Если другой поток уже захватил его, то текущий поток приостанавливает свою работу.
 * `pthread_mutex_trylock(pthread_mutex_t *mutex)` - пытается захватить мьютекс. В случае успеха возвращает значение `0`, а если мьютекс уже занят, то значение `EBUSY`.
 * `pthread_mutex_unlock(pthread_mutex_t *mutex)` - освободить ранее захваченный мьютекс. Сделать это может только тот поток, которые его захватил, в противном случае это приведет к ошибке `EPERM`.


Чтобы избежать гонок, можно обрамить обращения к разделяемым переменным взятием блокировки (см. `mutex.c`).

#### Deadlock
```C
void* f1(void*) {
    pthread_mutex_lock(&a);
    pthread_mutex_lock(&b); // ждет b
    return NULL;
}

void* f2(void*) {
    pthread_mutex_lock(&b);
    pthread_mutex_lock(&a); // ждет a
    return NULL;
}

int main() {
    pthread_t t1, t2;
    pthread_create(&t1, NULL, f1, NULL);
    pthread_create(&t2, NULL, f2, NULL);
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
}
```

Операции mutex в десятки раз медленнее большинства других, поэтому стоит минимизировать их количество.

## Condvar

Посмотрим на пример `spinlock`-а. Можно заметить, что пока один поток захватил mutex, остальные его ждут и простаивают. Это не очень эффективно, так как потоки нужны другим программам и мы попусту тратим ресурсы процессора(целое ядро пашет). Хотелось бы уметь усыплять такие потоки и будить при освобождение mutex'а. Это можно сделать с помощью механизма условных переменных, которые связываются с mutex'ом.

* `pthread_cond_init(pthread_cond_t *c, const pthread_condattr_t *attr)` - инициализации условной переменной.
* `pthread_cond_destroy(pthread_cond_t *c)` - уничтожить условную переменную.
* `pthread_cond_wait(pthread_cond_t *c, pthread_mutex_t *m)` - ожидает нотификации условной переменной переменной `c`, временно разблокируя мютекс `m`. Перед вызовом мьютекс должен находиться в заблокированном состоянии, в противном случае - неопределенное поведение. После наступления события нотификации, мьютекс опять блокируется.
* `pthread_cond_timedwait(pthread_cond_t *c, pthread_mutex_t *m, const struct timespec *timeout)` - то же, что и `pthread_cond_wait`, но ожидание прекращается по истечению указанного периода времени.
* `pthread_cond_signal(pthread_cond_t *c)` - уведомляет один поток, для которого выполняется ожидание нотификации. В общем случае, поток выбирается случайным образом, если их несколько.
* `pthread_cond_broadcast(pthread_cond_t *c)` - уведомляет все потоки, для которых выполняется ожидание нотификации.

В связи с особенностями реализации механизма условных переменных, бывают ложные пробуждения, поэтому засыпать в цикле ожидания нужно обязательно (см. `condvar_simple.c`, `condvar.c`).

## Semofore

Семафор — это счётчик, который управляет количеством потоков,
которым разрешено одновременно выполнять определённый участок кода или пользоваться ресурсом.


**`int sem_init(sem_t *sem, int pshared, unsigned int value)`** - Инициализация семафора                                                     

**`int sem_wait(sem_t *sem)`** - Уменьшает значение семафора (войти / занять ресурс). Если `0` — поток блокируется.             

**`int sem_trywait(sem_t *sem)`** - Попытка уменьшить семафор — если не получилось, сразу возвращает ошибку `EAGAIN`.              

**`int sem_post(sem_t *sem)`** - Увеличивает значение семафора (освободить ресурс). Если кто-то ждал — разблокирует один поток.

**`int sem_destroy(sem_t *sem)`** - Освобождает ресурсы, связанные с семафором.

Пример см. `semaphore.c`

## Атомарные переменные и неблокирующие структуры данных

Взятие блокировки -- дорогая операция сама по себе. Кроме того, пока блокировка взята, конкурирующие потоки простаивают. Это может сильно замедлять программу. 

Хочется научиться строить lock-free структуры данных. Строить мы их будем на основе атомарных переменных размером с машинное слово. 

Атомарными могут быть типа **размером с машинной слово**. Для этого нужно перед названием указать спецификатор ``_Atomic`` (пример в ``atomic.c``), а также спецификатор `volatile`, чтобы отключить оптимизации компилятора. Для операции с атомарными типами есть следующие макросы:

 * `void atomic_store(T* object, T value)`,
 * `void atomic_store_explicit(T* object, T value, memory_order order)` - сохранить значение в атомарную переменную.

`memory_order` — это способ сказать компилятору и процессору:
насколько строго ты хочешь упорядочить операции памяти.

 * `T atomic_load(T* object)`,
 * `T atomic_load_explicit(T* object, memory_order order)` - загрузить значение из переменной.
 * `T atomic_exchange(T* object, T new_value)`,
 * `T atomic_exchange_explicit(T* object, T new_value, memory_order order)` - заменить значение и вернуть предыдущее.
 * `_Bool atomic_compare_exchange_strong(T* object, T* expected, T new_value)`,
 * `_Bool atomic_compare_exchange_strong_explicit(T* object, T* expected, T new_value, memory_order success, memory_order failure)`,
 * `_Bool atomic_compare_exchange_weak(T* object, T* expected, T new_value)`,
 * `_Bool atomic_compare_exchange_weak_explicit(T* object, T* expected, T new_value, memory_order success, memory_order failure)` - сравнить два значения, в случае их равенства - заменить на новое, в противном случае - записать в `expected` значение `object`.
 * `T atomic_fetch_MOD(T* object, T operand)`,
 * `T atomic_fetch_MOD_explicit(T* object, T operand, memory_order order)` - получить значение переменной, после чего - модифицировать её. `MOD` можеть быть:
  - `add` - инкремент
  - `sub` - декремент
  - `and` - поразрядное "и"
  - `or` - поразрядное "или"
  - `xor` - поразрядное "исключающее или".

Про модели памяти вам расскажут в последующих курсах, а сейчас нам понадобятся только арифметические операции, `load`, `store` и `CAS` (так принято сокращать `compare_exchange_strong`).

> На самом деле, `CAS` все еще достаточно дорогой. Кроме того, lock-free алгоритмы сложны в реализации. Поэтому в реальной жизни блокирующая синхронизация горазо чаще. Более того, иногда она может работать быстрее неблокирующей.
 
 ## Lockfree stack

 Как реализовать стек без блокировок?